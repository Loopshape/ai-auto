#!/usr/bin/env bash

# --- AGI (Artificially Generated Interface) ---
# Version: 4.1
# A rich CLI tool for building Node.js executables, managing shell extensions,
# and interacting with a persistent, context-aware AI chat.

set -e
set -o pipefail

# --- Rich UI Configuration ---
RESET='\033[0m'
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'

# --- Utility Functions ---
fail() { echo -e "\n${BOLD}${RED}â Œ Error: $1${RESET}" >&2; exit 1; }
info() { echo -e "${BOLD}${BLUE}â„¹ï¸   $1${RESET}"; }
success() { echo -e "${BOLD}${GREEN}âœ… Success: $1${RESET}"; }
warn() { echo -e "${BOLD}${YELLOW}âš ï¸   Warning: $1${RESET}" >&2; }
header() {
    local title=" $1 "
    local len=${#title}
    local line=$(printf '%*s' "$len" | tr ' ' '=')
    echo -e "\n${BOLD}${YELLOW}===${line}===${RESET}"
    echo -e "${BOLD}${YELLOW}===${title}===${RESET}"
    echo -e "${BOLD}${YELLOW}===${line}===${RESET}\n"
}

run_with_spinner() {
    local cmd_to_run="$1"
    local message="$2"
    local spin='â— â— â—‘â—’'
    local i=0
    local log_file
    log_file=$(mktemp)

    echo -ne "${BLUE}${BOLD}   [ ] ${message}${RESET}"
    # Run command in the background, redirecting stdout/stderr to log file
    eval "$cmd_to_run" &> "$log_file" &
    local pid=$!

    # Trap to kill the command if the script exits
    trap "kill $pid 2> /dev/null" EXIT

    while kill -0 $pid 2>/dev/null; do
        i=$(( (i+1) %4 ))
        echo -ne "\r${BLUE}${BOLD}   [${spin:$i:1}] ${message}${RESET}"
        sleep 0.1
    done

    # Remove the trap
    trap - EXIT
    wait $pid
    local exit_code=$?

    if [ $exit_code -eq 0 ]; then
        echo -e "\r${GREEN}${BOLD}   [âœ”] ${message}${RESET}   "
        # Return the output from the command
        cat "$log_file"
    else
        echo -e "\r${RED}${BOLD}   [âœ—] ${message}${RESET}   "
        warn "Command failed. See details below:"
        cat "$log_file"
        rm "$log_file"
        fail "Process exited with code $exit_code."
    fi
    rm "$log_file"
}

# --- Usage Information ---
usage() {
    cat <<EOF
${BOLD}AGI (Artificially Generated Interface) - v4.1${RESET}

A rich CLI for building executables and interacting with a persistent AI chat.

${BOLD}Usage:${RESET}
  agi chat [options] [prompt]    Start or continue a chat session.
  agi build [options] <file>     Build a Node.js executable.
  agi install                    Install the agi command and shell prompt extension.
  agi uninstall                  Remove the agi command and shell extension.

${BOLD}Chat Options:${RESET}
  [prompt]                Send a single prompt to the AI.
  -c, --continue          Enter an interactive, continuous chat loop.
  -s, --show              Display the chat history for the current session.
  --clear                 Delete the chat history for the current session.

${BOLD}Build Options:${RESET}
  <file>                  The main entry point of your Node.js application.
  -o, --output DIR        Specify the output directory. (Default: ./dist)
  --native                Use the native Node.js Single Executable Application (SEA) feature.
  -t, --targets T         ('pkg' mode only) Comma-separated list of targets.

${BOLD}Other Options:${RESET}
  -h, --help              Show this help message.
EOF
    exit 0
}

# --- Core Logic: AI Chat Mode ---
run_chat_mode() {
    # ... [The entire run_chat_mode function from the previous answer goes here, unchanged] ...
    local initial_prompt="$1"
    local interactive_mode="$2"
    local show_history="$3"
    local clear_history="$4"

    local ai_wrapper="$HOME/bin/ai"
    local chat_log_file="./.agi_chat.json"

    command -v jq >/dev/null || fail "'jq' is not installed. It is required for chat mode. Please install it."
    [[ -x "$ai_wrapper" ]] || fail "AI wrapper script not found or not executable at '$ai_wrapper'."

    if [[ "$show_history" -eq 1 ]]; then
        header "Chat History"; if [[ ! -f "$chat_log_file" ]]; then info "No chat history found in this directory."; exit 0; fi
        jq -r '.[] | "[ \(.timestamp) | \(.role | ascii_upcase) ]\n\(.content)\n"' "$chat_log_file" | less -R; exit 0
    fi
    if [[ "$clear_history" -eq 1 ]]; then
        if [[ -f "$chat_log_file" ]]; then
            read -p "Are you sure you want to delete the chat history? [y/N]: " -r confirm
            if [[ "$confirm" =~ ^[Yy]$ ]]; then rm -f "$chat_log_file"; success "Chat history cleared."; else info "Clear operation cancelled."; fi
        else info "No chat history to clear."; fi; exit 0
    fi
    [[ -f "$chat_log_file" ]] || echo "[]" > "$chat_log_file"
    process_prompt() {
        local user_prompt="$1"; if [[ -z "$user_prompt" ]]; then return; fi
        local timestamp; timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
        local user_message_json; user_message_json=$(jq -n --arg ts "$timestamp" --arg content "$user_prompt" '{role: "user", timestamp: $ts, content: $content}')
        local updated_log; updated_log=$(jq --argjson msg "$user_message_json" '. + [$msg]' "$chat_log_file"); echo "$updated_log" > "$chat_log_file"
        local formatted_context; formatted_context=$(jq -r '.[] | "\(.role | ascii_upcase): \(.content)"' "$chat_log_file" | paste -sd '\n' -)
        local ai_response; ai_response=$(run_with_spinner "\"$ai_wrapper\" \"$formatted_context\"" "AGI is thinking...")
        timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
        local ai_message_json; ai_message_json=$(jq -n --arg ts "$timestamp" --arg content "$ai_response" '{role: "assistant", timestamp: $ts, content: $content}')
        updated_log=$(jq --argjson msg "$ai_message_json" '. + [$msg]' "$chat_log_file"); echo "$updated_log" > "$chat_log_file"
        echo -e "${BOLD}${CYAN}AGI:${RESET}\n${ai_response}"
    }
    if [[ "$interactive_mode" -eq 1 ]]; then
        header "AGI Interactive Chat"; info "Starting a new session. Type 'exit' or 'quit' to end."
        while true; do
            echo -e -n "${BOLD}${GREEN}You:${RESET} "; read -r user_input
            case "$user_input" in exit|quit) break ;; *) process_prompt "$user_input" ;; esac; echo ""
        done; success "Chat session ended."
    elif [[ -n "$initial_prompt" ]]; then process_prompt "$initial_prompt"; else usage; fi
}

# --- Core Logic: Build Mode ---
run_build_mode() {
    header "AGI Node.js Bundler"

    # --- Argument Parsing for Build ---
    local entry_file=""
    local output_dir="./dist"
    local targets=""
    local use_native_sea=0
    local no_sign=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -o|--output) [[ -n "$2" ]] && { output_dir="$2"; shift 2; } || fail "'--output' requires a directory.";;
            -t|--targets) [[ -n "$2" ]] && { targets="$2"; shift 2; } || fail "'--targets' requires a list.";;
            --native) use_native_sea=1; shift;;
            --no-sign) no_sign=1; shift;;
            -*) fail "Unknown build option: $1";;
            *) [[ -z "$entry_file" ]] && { entry_file="$1"; shift; } || fail "Only one entry file can be specified for build.";;
        esac
    done

    if [[ -z "$entry_file" ]]; then
        fail "You must specify an entry file for the build command."
    fi

    # --- Prerequisite Checks ---
    run_with_spinner "command -v node && command -v npm" "Checking for Node.js and npm"

    # --- Route to the correct build mode ---
    if [[ "$use_native_sea" -eq 1 ]]; then
        run_native_sea_mode "$entry_file" "$output_dir" "$no_sign"
    else
        run_pkg_mode "$entry_file" "$output_dir" "$targets"
    fi
}

run_pkg_mode() {
    # ... [The run_pkg_mode function from previous answers goes here, unchanged] ...
    # Make sure to adapt it to use run_with_spinner for the npm install and pkg commands
    local entry_file="$1"; local output_dir="$2"; local targets="$3"; info "Running in legacy 'pkg' mode..."
    if ! command -v pkg >/dev/null; then
        info "'pkg' command not found. It is required for this mode."; read -p "Install 'pkg' globally via npm? [y/N]: " -r confirm
        if [[ "$confirm" =~ ^[Yy]$ ]]; then run_with_spinner "npm install -g pkg" "Installing 'pkg' globally..."; else fail "Installation of 'pkg' cancelled."; fi
    fi
    info "Starting build with 'pkg'..."; mkdir -p "$output_dir"
    local pkg_command="pkg \"$entry_file\" --output-path \"$output_dir\""
    if [[ -n "$targets" ]]; then pkg_command+=" --targets \"$targets\""; fi
    run_with_spinner "$pkg_command" "Packaging application with 'pkg'"
    success "Build complete! Executable(s) are in '$output_dir'."
    ls -l "$output_dir"
}

run_native_sea_mode() {
    # ... [The run_native_sea_mode function from previous answers goes here, unchanged] ...
    # Make sure to adapt it to use run_with_spinner for postject
    local entry_file="$1"; local output_dir="$2"; local no_sign="$3"; info "Running in native SEA mode..."
    local node_major_version; node_major_version=$(node -v | cut -d'v' -f2 | cut -d'.' -f1); if (( node_major_version < 20 )); then fail "Native SEA mode requires Node.js v20+. You are using $(node -v)."; fi
    info "Step 1: Preparing assets for SEA build..."; mkdir -p "$output_dir"; local temp_dir; temp_dir=$(mktemp -d); trap 'rm -rf -- "$temp_dir"' EXIT
    cp "$entry_file" "$temp_dir/sea-entry.js"; node --experimental-sea-config "$temp_dir/sea-config.json"
    local blob_path="$output_dir/app.blob"; node -e "require('fs').copyFileSync(process.argv[1], process.argv[2])" "$temp_dir/sea-prep.blob" "$blob_path"; success "Blob created at '$blob_path'."
    local exe_name; exe_name=$(basename "$entry_file" .js); local node_path; node_path=$(command -v node); local final_exe_path="$output_dir/$exe_name"
    local os_type; os_type=$(uname -s); if [[ "$os_type" == "CYGWIN"* || "$os_type" == "MINGW"* || "$os_type" == "MSYS"* ]]; then final_exe_path+=".exe"; fi
    info "Step 2: Creating copy of Node.js executable..."; cp "$node_path" "$final_exe_path"; success "Executable copied to '$final_exe_path'."
    if [[ "$no_sign" -eq 0 ]]; then
        info "Step 3: Removing existing code signature..."; if [[ "$os_type" == "Darwin" ]]; then codesign --remove-signature "$final_exe_path" || warn "Failed to remove signature."; elif [[ "$os_type" != "Linux" ]]; then warn "Cannot automatically remove signature on Windows."; else info "(Not required on Linux)"; fi
    fi
    run_with_spinner "npx postject \"$final_exe_path\" NODE_SEA_BLOB \"$blob_path\" --sentinel-fuse NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2" "Step 4: Injecting blob into executable"
    if [[ "$no_sign" -eq 0 ]]; then
        info "Step 5: Re-signing the executable..."; if [[ "$os_type" == "Darwin" ]]; then codesign --sign - "$final_exe_path" || warn "Failed to sign executable."; elif [[ "$os_type" != "Linux" ]]; then warn "Please sign '$final_exe_path' manually with 'signtool'."; else info "(Not required on Linux)"; fi
    else warn "Skipping code signing as requested."; fi
    success "Native SEA build complete! Executable is at '$final_exe_path'."; ls -l "$final_exe_path"
}

# --- Core Logic: Installation ---
install_agi() {
    # ... [The install_agi function from previous answers goes here, unchanged] ...
    header "AGI Installation"; local install_dir="$HOME/.local/bin"; local agi_config_dir="$HOME/.agi"; local shell_config_file="$HOME/.bashrc"
    info "This will install the 'agi' command and a custom shell prompt."; mkdir -p "$install_dir"; mkdir -p "$agi_config_dir"
    info "Installing 'agi' command to $install_dir..."; cp -f "$0" "$install_dir/agi"; chmod +x "$install_dir/agi"
    if [[ ":$PATH:" != *":$install_dir:"* ]]; then warn "'$install_dir' is not in your PATH."; info "Please add 'export PATH=\"\$HOME/.local/bin:\$PATH\"' to your '$shell_config_file'."; fi
    info "Creating shell prompt extension at '$agi_config_dir/prompt.sh'..."; cat <<'EOF' > "$agi_config_dir/prompt.sh"
# --- AGI Custom Prompt Extension ---
parse_git_branch() { git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ (\1)/'; }
PS1="\[\033[0;32m\]\u@\h\[\033[0m\]:\[\033[0;34m\]\w\[\033[0m\]\[\033[0;33m\]\$(parse_git_branch)\[\033[0m\]\$ "
EOF
    local source_line="source \"$HOME/.agi/prompt.sh\""; if ! grep -qF -- "$source_line" "$shell_config_file"; then
        info "Adding source line to '$shell_config_file'..."; echo -e "\n# Load AGI Shell Extension\nif [ -f \"$HOME/.agi/prompt.sh\" ]; then\n    $source_line\nfi" >> "$shell_config_file"
        success "Installation complete!"; info "Please run 'source ~/.bashrc' or restart your terminal."; else success "AGI is already configured in your shell."; fi
}

uninstall_agi() {
    # ... [The uninstall_agi function from previous answers goes here, unchanged] ...
    header "AGI Uninstallation"; local install_dir="$HOME/.local/bin"; local agi_config_dir="$HOME/.agi"; local shell_config_file="$HOME/.bashrc"
    read -p "Are you sure you want to uninstall agi? [y/N]: " -r confirm; if [[ ! "$confirm" =~ ^[Yy]$ ]]; then info "Uninstallation cancelled."; exit 0; fi
    info "Removing 'agi' command..."; rm -f "$install_dir/agi"; info "Removing configuration directory..."; rm -rf "$agi_config_dir"
    info "Commenting out AGI extension from '$shell_config_file'..."; sed -i.bak "s|source \"$HOME/.agi/prompt.sh\"|# source \"$HOME/.agi/prompt.sh\" # Disabled by agi --uninstall|" "$shell_config_file"
    success "Uninstallation complete."; info "Please 'source ~/.bashrc' or restart your terminal."
}

# --- Main Execution ---
main() {
    if [[ $# -eq 0 ]]; then usage; fi

    local command="$1"; shift

    case "$command" in
        install|--install) install_agi ;;
        uninstall|--uninstall) uninstall_agi ;;
        build) run_build_mode "$@" ;;
        chat)
            local prompt=""
            local interactive=0; local show=0; local clear=0
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    -c|--continue) interactive=1; shift ;;
                    -s|--show) show=1; shift ;;
                    --clear) clear=1; shift ;;
                    -h|--help) usage ;;
                    *) prompt+="$1 "; shift ;;
                esac
            done
            run_chat_mode "${prompt% }" "$interactive" "$show" "$clear"
            ;;
        -h|--help) usage ;;
        *) fail "Unknown command: $command. Use 'agi --help' for usage." ;;
    esac
}

main "$@"
