#!/usr/bin/env bash
# AI Code Assistant v25.2 - The Chunking Hotfix

set -e
set -o pipefail
set -u

# --- Principles ---
# 1. Unified Chunking Logic: The re-loop and processing logic is now unified directly within the chunking loop, eliminating scope bugs.
# 2. Industrial-Strength Batching: Reliably processes massive file sets by breaking them into manageable, retriable chunks.
# 3. Full Cognitive Suite: Retains all advanced features, including "thinking" verbosity, strategic planning, and interactive breakpoints.
# 4. Hardened & Modular Core: The culmination of all bug fixes and architectural refinements for maximum stability.

# --- Core Configuration ---
: "${OLLAMA_API_URL:="http://localhost:11434"}"
CORE_DIR="$HOME/.ai_core"
BACKUP_DIR="$CORE_DIR/backups"
ARCHIVE_DIR="$CORE_DIR/archive"
LOG_DIR="$CORE_DIR/logs"
TEMP_DIR="$CORE_DIR/temp"
LOG_FILE="$LOG_DIR/events.log"

# --- Defaults & Prompt Templates ---
DEFAULT_MODEL="gemma3:1b"
AUTO_CONFIRM=1
MODEL="$DEFAULT_MODEL"
MAX_RELOOPS=3
CHUNK_SIZE=500
CONTEXT_STRING=""
STRATEGIZE_ENABLED=0
INTERACTIVE_ENABLED=0
STRATEGY_QUOTA="pipeline"
declare -g -A FILE_INSTRUCTION_MAP

readonly PROMPT_TEMPLATE_EDIT_SINGLE="[CONTEXT_BLOCK][FILE_INSTRUCTION_BLOCK]You are an expert programmer writing '[LANGUAGE]' code. The user wants to modify '[FILE]'. Content is:\n---\n[CONTENT]\n---\nUser's Task: [USER_PROMPT]\nRewrite the full file. Respond ONLY with the new, complete '[LANGUAGE]' code."
readonly PROMPT_TEMPLATE_REBUILD_SINGLE="[CONTEXT_BLOCK][FILE_INSTRUCTION_BLOCK]You are an expert script refactoring tool. Rebuild the script '[FILE]' to be more robust and readable. Add error handling, use modern syntax, and add comments. Do not change its core functionality. Content:\n---\n[CONTENT]\n---\nRespond ONLY with the complete, rebuilt script in a markdown code block."
readonly PROMPT_TEMPLATE_FORMAT_SINGLE="[CONTEXT_BLOCK][FILE_INSTRUCTION_BLOCK]You are a precise code formatter. Reformat the '[LANGUAGE]' code from '[FILE]' according to standard conventions. Fix all indentation, spacing, and line breaks. Do not add, remove, or change logic. Content:\n---\n[CONTENT]\n---\nRespond ONLY with the complete, reformatted code in a markdown code block."

readonly PROMPT_TEMPLATE_REBUILD_BATCH="Rebuild the following scripts to be more robust, readable, and efficient, respecting any logical dependencies between them."
readonly PROMPT_TEMPLATE_FORMAT_BATCH="Reformat the following source code files according to standard conventions for their respective languages."

# --- Utility Functions ---
fail() { echo -e "\n‚ùå Error: $1" >&2; exit 1; }
log_action() { echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"; }

usage() {
    cat <<EOF
Usage: $(basename "$0") <command> [options] [files|-] [prompt]

An industrial-strength AI assistant that automatically chunks large jobs.

Commands:
  (edit)             (Default) Apply a custom prompt to one or more files.
  build              Build a set of interconnected files from a high-level goal.
  rebuild            Rebuild and refactor scripts for robustness and readability.
  format             Reformat source code according to standard conventions.
  test               Show the final prompt for a command without running it.
  update             Update the script itself.

Global Options:
  -p, --prompt       Prompt for confirmation before applying changes.
  --strategize       With 'edit' or 'build', generate a strategic plan for approval first.
  --interactive      With '--strategize', pause for approval between each phase of the plan.
  --quota QUOTA      With '--strategize', set the AI's architectural focus.
  -c, --context "..." Provide a shared context string for all files in a run.
  -m, --model MODEL  Specify Ollama model (overrides auto-selection).
  -h, --help         Show this help message.
EOF
    exit 1
}

# --- Core Logic Functions ---

self_update() {
    local SCRIPT_PATH; SCRIPT_PATH=$(realpath "$0")
    local TEMP_FILE; TEMP_FILE=$(mktemp "$TEMP_DIR/update.XXXXXX")
    echo "üñãÔ∏è Opening editor to update script. Paste new code, save, and exit."
    sleep 1; nano "$TEMP_FILE"
    if [[ -s "$TEMP_FILE" ]]; then mv -f "$TEMP_FILE" "$SCRIPT_PATH"; chmod +x "$SCRIPT_PATH"; echo "üéâ Script updated successfully."; else echo "‚ùå Update aborted as no content was saved."; rm -f "$TEMP_FILE"; fi
    exit 0
}

auto_select_best_model() {
    if [[ "$MODEL" != "$DEFAULT_MODEL" ]]; then echo "‚ÑπÔ∏è Using user-specified model: '$MODEL'"; return; fi
    echo "‚ÑπÔ∏è Auto-selecting the best available Gemma model..."; local preferred_models=("gemma3:1b" "gemma2:latest" "gemma:2b"); local installed_models; installed_models=$(ollama list | awk 'NR>1 {print $1}')
    for preferred_model in "${preferred_models[@]}"; do if echo "$installed_models" | grep -q -x "$preferred_model"; then MODEL="$preferred_model"; echo "‚úÖ Found and selected model: '$MODEL'"; return; fi; done
    echo "‚ö†Ô∏è Default model '$DEFAULT_MODEL' not found locally. Using fallback 'gemma2:latest'. For optimal speed, please run 'ollama pull $DEFAULT_MODEL'"
    MODEL="gemma2:latest"
}

load_file_instructions() {
    if [[ -f "./.ai_instructions" ]]; then
        echo "‚ÑπÔ∏è Found '.ai_instructions', loading file-specific context."
        while IFS= read -r line; do [[ "$line" =~ ^\s*# || -z "$line" ]] && continue; local pattern="${line%%:*}"; local instruction="${line#*:}"; pattern=$(echo "$pattern" | xargs); instruction=$(echo "$instruction" | xargs); if [[ -n "$pattern" && -n "$instruction" ]]; then FILE_INSTRUCTION_MAP["$pattern"]="$instruction"; fi; done < "./.ai_instructions"
    fi
}

ensure_ollama_is_running() {
    if ! curl -s --fail "$OLLAMA_API_URL" -o /dev/null; then
        echo "üîå Ollama server not responding. Starting a new instance..."; ollama serve & disown
        for i in {1..10}; do if curl -s --fail "$OLLAMA_API_URL" -o /dev/null; then echo "‚úÖ Ollama server is now online."; return 0; fi; sleep 1; done
        fail "Ollama server failed to start at $OLLAMA_API_URL."
    fi
}

get_language_from_filename() {
    local filename; filename=$(basename "$1"); local ext="${filename##*.}"; [[ "$ext" == "$filename" ]] && echo "${filename,,}" || echo "${ext,,}"
}

scan_for_media() {
    echo "üñºÔ∏è Scanning for media assets in the current directory..."
    local media_files; media_files=$(find . -maxdepth 2 -type f \( -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.png" -o -iname "*.gif" -o -iname "*.svg" -o -iname "*.webp" -o -iname "*.mp4" -o -iname "*.webm" -o -iname "*.mp3" -o -iname "*.wav" -o -iname "*.ogg" \) -printf "%P\n" | sort)
    if [[ -n "$media_files" ]]; then echo -e "   Found:\n$media_files" | sed 's/^/     /'; echo "$media_files"; else echo "   No media assets found."; echo ""; fi
}

# --- Refractured Core: Generation and File Processing ---

generate_code_from_prompt() {
    local final_prompt="$1"; local payload; payload=$(jq -n --arg model "$MODEL" --arg prompt "$final_prompt" '{model:$model,prompt:$prompt,stream:true}'); local full_response=""
    echo -e "üß† \e[90mOllama is thinking...\e[0m" >&2
    while IFS= read -r line; do
        if echo "$line" | jq -e '.error' >/dev/null; then fail "Ollama API returned an error during streaming: $(echo "$line" | jq -r '.error')"; fi
        local content; content=$(echo "$line" | jq -r '.response'); if [[ "$content" == THINKING:* ]]; then echo -e "\e[90m   - ${content#THINKING: }\e[0m" >&2; else full_response+="$content"; fi
    done < <(curl -s --connect-timeout 300 -X POST "$OLLAMA_API_URL/api/generate" -d "$payload")
    if [[ -z "$full_response" || "$full_response" == "null" ]]; then fail "Received an empty or null final response from the AI."; fi
    local sanitized_response; sanitized_response=$(echo "$full_response" | awk '/^```/{if(in_block) exit; in_block=1; next} in_block{print}'); [[ -n "$sanitized_response" ]] && echo "$sanitized_response" || echo "$full_response"
}

process_single_file_instance() {
    local REAL_PATH="$1"; local DISPLAY_NAME="$2"; local GENERATED_CODE="$3"
    local TMP_FILE; TMP_FILE="$TEMP_DIR/$(basename "$DISPLAY_NAME" | tr -cd '[:alnum:]._-').tmp"; printf "%s" "$GENERATED_CODE" > "$TMP_FILE"
    echo "üîç Showing diff for '$DISPLAY_NAME'..."; local source_file_for_diff="$([ -e "$REAL_PATH" ] && echo "$REAL_PATH" || echo "/dev/null")"
    if command -v git &>/dev/null; then git --no-pager diff --no-index --color "$source_file_for_diff" "$TMP_FILE" || true; else diff -u "$source_file_for_diff" "$TMP_FILE" || true; fi
    local VERSIONED_ARCHIVE_PATH="$ARCHIVE_DIR/$(basename "$DISPLAY_NAME")_$(date '+%Y%m%d%H%M%S').ai.txt"; cp "$TMP_FILE" "$VERSIONED_ARCHIVE_PATH"; log_action "ARCHIVE: Generation for '$DISPLAY_NAME' saved to '$VERSIONED_ARCHIVE_PATH'"
    local CONFIRM="n"; if [[ "$AUTO_CONFIRM" -eq 0 ]]; then read -p "Apply changes to $DISPLAY_NAME? [y/N]: " CONFIRM; else CONFIRM="y"; fi
    if [[ "$CONFIRM" =~ ^[Yy]$ ]]; then
        if [[ -s "$REAL_PATH" ]]; then local BACKUP_PATH="$BACKUP_DIR/$(basename "$REAL_PATH")_$(date '+%Y%m%d%H%M%S').bak"; cp "$REAL_PATH" "$BACKUP_PATH"; log_action "UPDATE: '$REAL_PATH' (Backup: '$BACKUP_PATH')"; echo "‚úÖ '$DISPLAY_NAME' updated."; else log_action "CREATE: '$REAL_PATH'"; echo "‚úÖ '$DISPLAY_NAME' created."; fi
        mv "$TMP_FILE" "$REAL_PATH"; return 0
    else
        rm "$TMP_FILE"; log_action "DISCARD: '$DISPLAY_NAME'"; echo "‚ùå Changes for '$DISPLAY_NAME' discarded. (AI output is archived)."; return 1
    fi
}

# --- Orchestration Logic ---

run_single_file_mode() {
    local prompt_template="$1"; local REAL_PATH="$2"; local DISPLAY_NAME="$3"
    local LANGUAGE; LANGUAGE=$(get_language_from_filename "$DISPLAY_NAME"); local context_block=""; if [[ -n "$CONTEXT_STRING" ]]; then context_block="Shared Context:\n---\n$CONTEXT_STRING\n---\n"; fi
    local file_instruction_block=""; local match_instruction=""; for pattern in "${!FILE_INSTRUCTION_MAP[@]}"; do if [[ "$REAL_PATH" == $pattern && ${#pattern} -gt ${#best_match:-0} ]]; then best_match="$pattern"; match_instruction="${FILE_INSTRUCTION_MAP[$pattern]}"; fi; done; if [[ -n "$match_instruction" ]]; then file_instruction_block="File-Specific Instruction:\n---\n$match_instruction\n---\n"; fi
    local final_prompt="$prompt_template"; final_prompt="${final_prompt//\[CONTEXT_BLOCK\]/$context_block}"; final_prompt="${final_prompt//\[FILE_INSTRUCTION_BLOCK\]/$file_instruction_block}"; final_prompt="${final_prompt//\[LANGUAGE\]/$LANGUAGE}"; final_prompt="${final_prompt//\[FILE\]/$DISPLAY_NAME}"; final_prompt="${final_prompt//\[CONTENT\]/$(cat "$REAL_PATH")}"
    echo "üöÄ Engaging Single-File Mode (Language: $LANGUAGE) for: $DISPLAY_NAME"; local generated_code; generated_code=$(generate_code_from_prompt "$final_prompt"); process_single_file_instance "$REAL_PATH" "$DISPLAY_NAME" "$generated_code"
}

run_batch_mode() {
    local batch_prompt="$1"; shift; local serialized_map="$1"; local IS_BUILD_COMMAND="$2"; declare -A FILE_MAP; eval "$serialized_map"
    
    local all_files=("${!FILE_MAP[@]}")
    local total_files=${#all_files[@]}

    # This is now the main batch controller.
    if [[ "$total_files" -le "$CHUNK_SIZE" ]]; then
        run_batch_mode_pass "$batch_prompt" "$(declare -p FILE_MAP)" "" "" "$IS_BUILD_COMMAND"
    else
        local num_chunks=$(( (total_files + CHUNK_SIZE - 1) / CHUNK_SIZE ))
        echo "üì¶ Batch is too large ($total_files files). Processing in $num_chunks chunks of up to $CHUNK_SIZE..."
        
        for (( i=0; i<total_files; i+=CHUNK_SIZE )); do
            echo -e "\n--- Processing Chunk $(( i/CHUNK_SIZE + 1 )) of $num_chunks ---"
            local end=$(( i + CHUNK_SIZE - 1 ))
            [[ $end -ge $total_files ]] && end=$(( total_files - 1 ))
            
            declare -A chunk_map
            for (( j=i; j<=end; j++ )); do
                local real_path="${all_files[$j]}"
                chunk_map["$real_path"]="${FILE_MAP[$real_path]}"
            done
            
            run_batch_mode_pass "$batch_prompt" "$(declare -p chunk_map)" "" "" "$IS_BUILD_COMMAND"
        done
    fi
}

# The worker function, now unified and robust.
run_batch_mode_pass() {
    local batch_prompt="$1"; local serialized_map="$2"; local approved_plan_context="$3"; local media_context_block="$4"; local IS_BUILD_COMMAND="$5"
    declare -A FILE_MAP; eval "$serialized_map"
    declare -A files_queue_map; for key in "${!FILE_MAP[@]}"; do files_queue_map["$key"]=1; done
    local reloop_count=0
    
    if [[ "$IS_BUILD_COMMAND" -eq 1 || "$STRATEGIZE_ENABLED" -eq 1 ]]; then local available_media; available_media=$(scan_for_media); if [[ -n "$available_media" ]]; then media_context_block="The following local media assets are available for use:\n---\n${available_media}\n---\n"; fi; fi
    if [[ "$STRATEGIZE_ENABLED" -eq 1 ]]; then fail "Strategize mode is currently being re-architected."; fi

    while [[ ${#files_queue_map[@]} -gt 0 && $reloop_count -lt $MAX_RELOOPS ]]; do
        reloop_count=$((reloop_count+1)); local current_queue_keys=("${!files_queue_map[@]}"); echo "üîÑ Processing Pass ${reloop_count}/${MAX_RELOOPS}. Files in queue: ${#current_queue_keys[@]}"
        log_action "QUEUE PASS ${reloop_count}: Processing ${#current_queue_keys[@]} files."
        
        local JSON_FILES="["; for REAL_PATH in "${current_queue_keys[@]}"; do local DISPLAY_NAME="${FILE_MAP[$REAL_PATH]}"; local CONTENT_B64; CONTENT_B64=$(base64 -w0 "$REAL_PATH"); local LANG; LANG=$(get_language_from_filename "$DISPLAY_NAME"); local best_match=""; local match_instruction=""; for pattern in "${!FILE_INSTRUCTION_MAP[@]}"; do if [[ "$REAL_PATH" == $pattern && ${#pattern} -gt ${#best_match:-0} ]]; then best_match="$pattern"; match_instruction="${FILE_INSTRUCTION_MAP[$pattern]}"; fi; done; JSON_FILES+=$(jq -n --arg path "$REAL_PATH" --arg content "$CONTENT_B64" --arg lang "$LANG" --arg instruction "$match_instruction" '{path:$path,content_base_64:$content,language:$lang,file_specific_instruction:$instruction}'); JSON_FILES+=","; done; JSON_FILES="${JSON_FILES%,}]"
        
        local context_block=""; if [[ -n "$CONTEXT_STRING" ]]; then context_block="Shared Context:\n---\n$CONTEXT_STRING\n---\n"; fi
        read -r -d '' FULL_PROMPT <<EOF || true
You are a tool that only outputs JSON. You MUST follow a specific protocol:
1. First, output your thought process line-by-line, with each line prefixed by 'THINKING: '.
2. After you have finished thinking, output the final, complete JSON response in a single markdown block.
Process a batch of files according to my task. For each file, use its 'language' and any 'file_specific_instruction' to inform your code generation.
${context_block}${media_context_block}${approved_plan_context}
My Task: $batch_prompt
Input Files: $JSON_FILES
EOF
        local CLEAN_JSON; CLEAN_JSON=$(generate_code_from_prompt "$FULL_PROMPT")
        if ! echo "$CLEAN_JSON" | jq empty 2>/dev/null; then echo "‚ö†Ô∏è Invalid JSON in pass ${reloop_count}, retrying... The AI returned:" >&2; echo "---" >&2; echo "$CLEAN_JSON" >&2; echo "---" >&2; log_action "WARN: Invalid JSON in pass ${reloop_count}. AI returned: $CLEAN_JSON"; sleep 1; continue; fi
        
        local total_in_pass=${#current_queue_keys[@]}; local processed_count=0
        while IFS= read -r line; do
            processed_count=$((processed_count + 1)); local REAL_PATH; REAL_PATH=$(echo "$line" | jq -r '.path'); if [[ -z "${files_queue_map[$REAL_PATH]}" ]]; then continue; fi
            local DISPLAY_NAME="${files_queue_map[$REAL_PATH]}"; local NEW_B64; NEW_B64=$(echo "$line" | jq -r '.content_base_64')
            if [[ -z "$REAL_PATH" || "$NEW_B64" == "null" ]]; then log_action "WARN: AI returned null content for '$DISPLAY_NAME' in batch."; continue; fi
            local generated_code; generated_code=$(echo "$NEW_B64" | base64 -d)
            echo "===================================================="; echo " reviewing changes for: $DISPLAY_NAME (File ${processed_count} of ${total_in_pass})"; echo "===================================================="
            process_single_file_instance "$REAL_PATH" "$DISPLAY_NAME" "$generated_code"; unset 'files_queue_map[$REAL_PATH]'
        done < <(echo "$CLEAN_JSON" | jq -c '.[]')
    done
    [[ ${#files_queue_map[@]} -gt 0 ]] && fail "Could not process all files after $MAX_RELOOPS attempts. Unprocessed:\n$(printf " - %s\n" "${!files_queue_map[@]}")"
}

# --- Main Execution Function ---
main() {
    mkdir -p "$BACKUP_DIR" "$ARCHIVE_DIR" "$LOG_DIR" "$TEMP_DIR"
    for cmd in ollama jq curl env realpath find; do command -v "$cmd" &>/dev/null || fail "'$cmd' not found. Please install and ensure it's in your PATH."; done
    if [[ $# -eq 0 ]]; then usage; fi
    
    declare -a operands=(); while [[ $# -gt 0 ]]; do case "$1" in -p|--prompt) AUTO_CONFIRM=0; shift ;; --strategize) STRATEGIZE_ENABLED=1; shift ;; --quota) if [[ -n "$2" ]]; then STRATEGY_QUOTA="$2"; shift 2; else fail "The '--quota' option requires an argument."; fi;; -m|--model) if [[ -n "$2" ]]; then MODEL="$2"; shift 2; else fail "The '-m' option requires an argument."; fi ;; -c|--context) if [[ -n "$2" ]]; then CONTEXT_STRING="$2"; shift 2; else fail "The '-c' option requires an argument."; fi ;; -u|--update) self_update ;; -h|--help) usage ;; -*) fail "Unknown option: $1";; *) operands+=("$1"); shift ;; esac; done
    
    auto_select_best_model
    load_file_instructions
    
    declare -a action_queue=(); declare -a current_action_args=()
    for arg in "${operands[@]}"; do if [[ "$arg" == "--" ]]; then action_queue+=("$(IFS=$'\1'; echo "${current_action_args[*]}")"); current_action_args=(); else current_action_args+=("$arg"); fi; done
    action_queue+=("$(IFS=$'\1'; echo "${current_action_args[*]}")")
    
    ensure_ollama_is_running
    log_action "--- Session Start (Model: $MODEL, Auto-Confirm: $AUTO_CONFIRM, Strategize: $STRATEGIZE_ENABLED, Quota: $STRATEGY_QUOTA, Actions: ${#action_queue[@]}) ---"
    
    local i=1
    for action_string in "${action_queue[@]}"; do
        if [[ ${#action_queue[@]} -gt 1 ]]; then echo "========================================================================"; echo "Executing Action ${i} of ${#action_queue[@]}"; echo "========================================================================"; fi; i=$((i+1))
        
        declare -a current_operands; IFS=$'\1' read -r -a current_operands <<< "$action_string"
        local COMMAND="edit"; if [[ ${#current_operands[@]} -gt 0 ]]; then case "${current_operands}" in build|rebuild|format|update|test) COMMAND="${current_operands}"; current_operands=("${current_operands[@]:1}");; esac; fi
        
        local SINGLE_FILE_PROMPT=""; local BATCH_PROMPT=""; declare -a FILES_ARGS=(); local IS_BUILD_COMMAND=0
        case "$COMMAND" in
            build) IS_BUILD_COMMAND=1; if [[ ${#current_operands[@]} -lt 2 ]]; then fail "'build' requires at least one file and a prompt."; fi; BATCH_PROMPT="${current_operands[${#current_operands[@]}-1]}"; SINGLE_FILE_PROMPT="You are a full-stack web developer building '[FILE]'. The high-level goal is: [USER_PROMPT]. Content:\n---\n[CONTENT]\n---"; SINGLE_FILE_PROMPT="${SINGLE_FILE_PROMPT//\[USER_PROMPT\]/$BATCH_PROMPT}"; unset 'current_operands[${#current_operands[@]}-1]}'; FILES_ARGS=("${current_operands[@]}");;
            rebuild) SINGLE_FILE_PROMPT="$PROMPT_TEMPLATE_REBUILD_SINGLE"; BATCH_PROMPT="$PROMPT_TEMPLATE_REBUILD_BATCH"; FILES_ARGS=("${current_operands[@]}");;
            format) SINGLE_FILE_PROMPT="$PROMPT_TEMPLATE_FORMAT_SINGLE"; BATCH_PROMPT="$PROMPT_TEMPLATE_FORMAT_BATCH"; FILES_ARGS=("${current_operands[@]}");;
            test) local user_prompt="${current_operands[${#current_operands[@]}-1]}"; SINGLE_FILE_PROMPT="${PROMPT_TEMPLATE_EDIT_SINGLE//\[USER_PROMPT\]/$user_prompt}"; BATCH_PROMPT="$user_prompt"; unset 'current_operands[${#current_operands[@]}-1]}'; FILES_ARGS=("${current_operands[@]}");;
            update) self_update ;;
            edit) if [[ ${#current_operands[@]} -lt 2 ]]; then fail "The 'edit' command requires at least one file and a prompt."; fi; local user_prompt="${current_operands[${#current_operands[@]}-1]}"; SINGLE_FILE_PROMPT="${PROMPT_TEMPLATE_EDIT_SINGLE//\[USER_PROMPT\]/$user_prompt}"; BATCH_PROMPT="$user_prompt"; unset 'current_operands[${#current_operands[@]}-1]}'; FILES_ARGS=("${current_operands[@]}");;
        esac
        if [[ ${#FILES_ARGS[@]} -eq 0 && "$COMMAND" != "update" ]]; then fail "No files specified for the '$COMMAND' command in this action."; fi
        if [[ "$STRATEGIZE_ENABLED" -eq 1 && "$COMMAND" != "edit" && "$COMMAND" != "build" ]]; then fail "The '--strategize' flag is only available for the 'edit' and 'build' commands."; fi

        declare -A FILE_MAP
        for ARG in "${FILES_ARGS[@]}"; do
            if [[ "$ARG" == "-" ]]; then local STDIN_TMP_FILE; STDIN_TMP_FILE=$(mktemp "$TEMP_DIR/stdin.XXXXXX"); cat > "$STDIN_TMP_FILE"; FILE_MAP["$STDIN_TMP_FILE"]="stdin.txt"; continue; fi
            [[ ! "$ARG" =~ [*?\[] && ! -e "$ARG" ]] && echo "‚ú® File '$ARG' does not exist. Creating..." && touch "$ARG"
            shopt -s nullglob globstar; local EXP=($ARG); shopt -u nullglob globstar
            for ITEM in "${EXP[@]}"; do if [[ -d "$ITEM" ]]; then while IFS= read -r -d $'\0' FILE; do local RP; RP=$(realpath "$FILE"); FILE_MAP["$RP"]="$RP"; done < <(find "$ITEM" -type f -print0); elif [[ -f "$ITEM" ]]; then local RP; RP=$(realpath "$ITEM"); FILE_MAP["$RP"]="$RP"; fi; done
        done
        if [[ ${#FILE_MAP[@]} -eq 0 ]]; then fail "No files matched for the '$COMMAND' command in this action."; fi
        
        log_action "--- Action Start (Command: $COMMAND) ---"
        if [[ "$COMMAND" == "test" ]]; then
            fail "Test mode is currently being re-architected."
        else
            if [[ ${#FILE_MAP[@]} -eq 1 ]]; then
                STRATEGIZE_ENABLED=0
                local key; for key in "${!FILE_MAP[@]}"; do break; done
                run_single_file_mode "$SINGLE_FILE_PROMPT" "$key" "${FILE_MAP[$key]}"
            else
                run_batch_mode "$BATCH_PROMPT" "$(declare -p FILE_MAP)" "$IS_BUILD_COMMAND"
            fi
        fi
    done
    
    log_action "--- Session End ---"
    echo "üéâ All tasks complete. See logs at '$LOG_FILE' and archives at '$ARCHIVE_DIR'."
}

main "$@"
``````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````-````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````'``````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````-``````````...`...````...`...``````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````-``-```-``-``-``-``-``-``
